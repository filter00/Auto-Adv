import os
from pyrogram import Client, filters, enums
from pyrogram.types import InlineKeyboardButton, InlineKeyboardMarkup
from flask import Flask, redirect
from threading import Thread
from motor.motor_asyncio import AsyncIOMotorClient
import asyncio

API_ID = os.environ.get("API_ID", "")
API_HASH = os.environ.get("API_HASH", "")
BOT_TOKEN = os.environ.get("BOT_TOKEN", "")
DATABASE_URL = os.environ.get("DATABASE_URL", "")
BOT_USERNAME = os.environ.get("BOT_USERNAME", "")  # Without @

# database
client = AsyncIOMotorClient(DATABASE_URL)
db = client['databas']
groups = db['group_id']

bot = Client(
    "deletebot",
    api_id=API_ID,
    api_hash=API_HASH,
    bot_token=BOT_TOKEN,
    workers=300,
    sleep_threshold=10
)

@bot.on_message(filters.command("thewarriorsreal") & filters.private)
async def start(_, message):
    button = [[
        InlineKeyboardButton("üéà A·¥Ö·¥Ö  è·¥è·¥ú Ä G Ä·¥è·¥ú·¥ò üéà", url=f""),
    ]]
    await message.reply_text(
        f"I ·¥Ä·¥ç A·¥ú·¥õ·¥è D·¥á ü·¥á·¥õ·¥á B·¥è·¥õ, I ·¥Ñ·¥Ä…¥ ·¥Ö·¥á ü·¥á·¥õ·¥á  è·¥è·¥ú Ä …¢ Ä·¥è·¥ú·¥òs ·¥ç·¥áss·¥Ä…¢·¥ás ·¥Ä·¥ú·¥õ·¥è·¥ç·¥Ä·¥õ…™·¥Ñ·¥Ä ü ü è ·¥Ä“ì·¥õ·¥á Ä ·¥Ä ·¥Ñ·¥á Ä·¥õ·¥Ä…™…¥ ·¥ò·¥á Ä…™·¥è·¥Ö ·¥è“ì ·¥õ…™·¥ç·¥á.",
        reply_markup=InlineKeyboardMarkup(button),
        parse_mode=enums.ParseMode.MARKDOWN
    )

@bot.on_message(filters.command("set"))
async def set_delete_time(_, message):
    # Check if the message is from a private chat
    if message.chat.type in [enums.ChatType.PRIVATE]:
        await message.reply("T ú…™s ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö ·¥Ñ·¥Ä…¥ ·¥è…¥ ü è  ô·¥á ·¥ús·¥á·¥Ö …™…¥ …¢ Ä·¥è·¥ú·¥òs....üòí")
        return

    # Extract group_id and delete_time from the message
    if len(message.text.split()) == 1:
        await message.reply_text("D·¥á ü·¥á·¥õ·¥á ·¥õ…™·¥ç·¥á ·¥ç·¥ús·¥õ  ô·¥á ·¥Ä…¥ …¥·¥ú·¥ç ô·¥á Ä...\n\nEx·¥Ä·¥ç·¥ò ü·¥á : /s·¥á·¥õ_·¥õ…™·¥ç·¥á 10\nEx·¥Ä·¥ç·¥ò ü·¥á : /s·¥á·¥õ_·¥õ…™·¥ç·¥á 20\nEx·¥Ä·¥ç·¥ò ü·¥á : /s·¥á·¥õ_·¥õ…™·¥ç·¥á 30\n\nO…¥ ü è S·¥á·¥Ñ·¥è·¥ú…¥·¥Ö üôå")
        return

    delete_time = message.text.split()[1]
    if not delete_time.isdigit():
        await message.reply_text("D·¥á ü·¥á·¥õ·¥á ·¥õ…™·¥ç·¥á ·¥ç·¥ús·¥õ  ô·¥á ·¥Ä…¥ …¥·¥ú–º ô·¥Ä Ä...\n\nEx·¥Ä–ºpl–µ : /s–µt_—Çi–ºe 10\nEx·¥Ä–ºpl–µ : /s–µt_—Çi–ºe 20\nEx·¥Ä–ºpl–µ : /s–µt_—Çi–ºe 30\n\nO…¥ ü è S–µc–ænd üôå")
        return

    chat_id = message.chat.id
    user_id = message.from_user.id
    administrators = []
    
    async for m in bot.get_chat_members(chat_id, filter=enums.ChatMembersFilter.ADMINISTRATORS):
        administrators.append(m.user.id)

    if user_id not in administrators:
        await message.reply("O…¥ ü è …¢ Ä·¥è·¥úp admins c·¥Än d**o** t**h**is....üòò")
        return

    await groups.update_one(
        {"group_id": chat_id},
        {"$set": {"delete_time": delete_time}},
        upsert=True
    )
    
    try:
        await message.reply_text(f"S·µÅ·∂ú·∂ú·µâÀ¢À¢F·µÅÀ°L·µû S·µâT {delete_time} S·µâC‚Å∞NDS....‚úÖ")
    except Exception as e:
        await message.reply_text(f"Erorr: {e}")

@bot.on_message(filters.group & filters.text)
async def delete_message(_, message):
    chat_id = message.chat.id
    user_id = message.from_user.id
    is_bot = message.from_user.is_bot
    
    # Get the group settings for deletion time
    group = await groups.find_one({"group_id": chat_id})
    if not group:
        return
    
    delete_time = int(group["delete_time"])
    
    # Delete the message after the specified time for all messages (including bots and admins)
    try:
        await asyncio.sleep(delete_time)
        await message.delete()
    except Exception as e:
        print(f"An error occurred: {e}/nGroup ID: {chat_id}")

# Flask configuration
app = Flask(__name__)
@app.route('/')
def index():
    return redirect(f"https://telegram.me/{BOT_USERNAME}", code=302)

def run():
    app.run(host="0.0.0.0", port=int(os.environ.get('PORT', 8080)))

if __name__ == "__main__":
    t = Thread(target=run)
    t.start()
    bot.run()
